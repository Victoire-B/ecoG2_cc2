---
title: "CC2 : Dada2  analysis"
output: 
  github_document:
    toc: true
    toc depth: 4
---

# Methods 
## Amplicon bioinformatics: from raw reads 

```{r}
set.seed(100)
```

```{r}
library(dada2)
```
Lister les séquences du 10 sept 14 et du 11 mars 15 et attribuer une variable
```{r}
path <- "~/EcoG2-CC2/Seqreunies2" # CHANGE ME to the directory containing the fastq files after unzipping.
list.files(path)
```
On voit les fichiers fastq

On crée des variables pour l'analyse du plot, les Read 1 vont dans la variable fnFs et les Read2 dans la variable fnRs

- la foction sample.names : extrait les noms des échantillons, tout en supposant que les noms de fichiers ont un format : NOM DE L'ÉCHANTILLON_XXX.fastq

## Filter and trim

On filtre les séquences de basses qualités et on les enlève
Lecture des dossiers fast, liste chaines 
F : forward = read1
R : reverse = read2
Affiche des scores de qualité 

fn : nouvelle variable qui recoit une liste de  fichier, recoit les R1 trié par ordre alphabétique pour Rs : la même chose pour les R2.

On cherche les profils qualité
Scrore de qualité pour les premiers reads
fnFs
```{r}
# Forward and reverse fastq filenames have format: SAMPLENAME_R1_1.fastq and SAMPLENAME_R2_1.fastq
fnFs <- sort(list.files(path, pattern="_R1.fastq", full.names = TRUE))
fnRs <- sort(list.files(path, pattern="_R2.fastq", full.names = TRUE))
# Extract sample names, assuming filenames have format: SAMPLENAME_XXX.fastq
sample.names <- sapply(strsplit(basename(fnFs), "R"), `[`, 1)
```

```{r}
plotQualityProfile(fnFs[1:2])
```

Des reverses (= les reads 2)
```{r}
plotQualityProfile(fnRs[1:2])
```
La fonction plot quality profil permet de voir à quel endroit on va couper les R1 et R2 pour qu'il y ait un overlap mais pour que le score de qualité ne soit pas inférieur 30% (c'est à dire le Q30). Pour les forwards, on peut couper à 240 nucléotides pour les reverse, on doit couper à 200 nucléotides. Couper à 200 nucléotides pour les R2 semble être la limite pour un bon score de qualité.

### Définir les noms de fichiers pour les fichiers fastq.gz filtrés
```{r}
# Place filtered files in filtered/ subdirectory
filtFs <- file.path(path, "filtered", paste0(sample.names, "_F_filt.fastq.gz"))
filtRs <- file.path(path, "filtered", paste0(sample.names, "_R_filt.fastq.gz"))
names(filtFs) <- sample.names
names(filtRs) <- sample.names
```
Les paramètres de filtrage standards : 
- truncLen=c : prend les deux (forward et reverse) et on coupe au niveau respectif de 240 pb et 200pb environ au niveua ou le score quality est en dessous de Q30
-trimLeft : coupe les 21 premiers nucléotides, ce sont les primers
-maxN=0 (Dada2 ne nécessite pas de Ns), 
-truncQ=2 : on va tronquer pour les reads 1 a 240 et 200 pour les reads 2
-rm.phix=TRUE 
-maxEE=2  -> le nombre maximum d'"erreurs attendues" autorisées dans une lecture, ce qui est un meilleur filtre que la simple moyenne des scores de qualité
```{r}
out<-filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen=c(240,200),trimLeft=21,
              maxN=0, maxEE=c(2,2), truncQ=2, rm.phix=TRUE,
              compress=TRUE, multithread=TRUE) # On Windows set multithread=FALSE
```
```{r}
head(out)
```
La fonction head() afiche les premiers read in et out des séquences récupérées 

## Apprentissage des erreurs 

Il est possible d'avoir des erreurs, avec Dada2 on inspecte les séquences. 
On utilise un modèle d'erreur paramétrique err pour les R1 et R2 

Le modèle d'erreur de DADA2  permet identifier les positions avec une forte probabilité d'erreur et par la suite changer avec la base la plus probable. Cela veut dire celle qui est présente dans la séquence la plus abondante

On crée les variables : 
-errF : recoit le modèle d'erreur paramétrique par la fonction LearnErrors pour les R1 et R2 filtrés 

```{r}
errF <- learnErrors(filtFs, multithread=TRUE)
```
Cela nous donne le nombre de base dans le nombre de reads à partir de 3 échantillons pour connaitre le taux d'erreur pour les R1. On fait ensuite la même chose avec les R2
```{r}
errR <- learnErrors(filtRs, multithread=TRUE)
```

## Visualisation des modèles d'ereur du forward

En abscisse on a la probabilité des mutations et en ordonnée le q score
Q30 : la probabilité que la base trouver sois la bonne 
La fonction plotError permet de visualiser les erreurs. 

```{r}
plotErrors(errF, nominalQ=TRUE)
```

```{r}
plotErrors(errR, nominalQ=TRUE)
```
Chaque transition (mutation) possible (A→C, A→G, ...) le taux d'erreur sont indiqués. 
-points : les taux d'erreur observés pour chaque score de qualité du consensus. 
-ligne noire : taux d'erreur estimés après convergence de l'algorithme de la machine d'apprentissage. 
-ligne rouge : taux d'erreur attendus selon la définition nominale du Q-score.
Les fenêtres montrent les replacements d'une base à une autre.
Quand on remplace les A avec les T et les T avec les A, la courbe se rapproche du taux d'erreur attendue selon la définition du Q-score.


## Exemple d'interférences

Dans deux nouvelles variables (pour les R1 et les R2),où est appliqué la fonction dada() avec le modèle d'erreur et les reads filtrés dont on a enlevé les bases au délà d'un Q-score inférieru à 30. 
```{r}
dadaFs <- dada(filtFs, err=errF, multithread=TRUE)
```

```{r}
dadaRs <- dada(filtRs, err=errR, multithread=TRUE)
```

Cette fonction permet d'enlever le bruit des paires de forward et des reverse 

Pour chaque échantillon, dada2 nous donne le résultats du nombre de reads avec des séquences uniques. 
```{r}
mergers <- mergePairs(dadaFs, filtFs, dadaRs, filtRs, verbose=TRUE)
# Inspect the merger data.frame from the first sample
head(mergers[[1]])
```
On a appliqué la fonction mergePairs() qui permet d'associer les R1 et le R2 par paires de lecture sans bruit (filtrés) en éliminant les reads qui ne chevauchent pas assez (overlap) ou justement ceux qui ont une trop grande disconcordance dans ce chevauchement.
```{r}
seqtab <- makeSequenceTable(mergers)
dim(seqtab)
```

# Inspection des longueurs de séquences
```{r}
table(nchar(getSequences(seqtab)))
```
# Chimères
## Enlever les chimères par méthode consensus 

```{r}
seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)
dim(seqtab.nochim)
```
## Faire le ratio

Voir le nombre de chimères, c'est le pourcentage de chimères dans notre échantillon
```{r}
1- sum(seqtab.nochim)/sum(seqtab)
```
Ic, on obtient 22% de chimères


# Construction d'une table 

```{r}
getN <- function(x) sum(getUniques(x))
track <- cbind(out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, getN), rowSums(seqtab.nochim))
# If processing a single sample, remove the sapply calls: e.g. replace sapply(dadaFs, getN) with getN(dadaFs)
colnames(track) <- c("input", "filtered", "denoisedF", "denoisedR", "merged", "nonchim")
rownames(track) <- sample.names
head(track)
```

#Assignation taxonomique

```{r}
taxa <- assignTaxonomy(seqtab.nochim, "~/EcoG2-CC2/silva_nr99_v138_train_set.fa.gz", multithread=TRUE)
```
On va comparer les séquences de nos échantillons grâce à la base de données Silva.

## Assignation taxonomique n°2 Silva species assignement

On va comparer nos séquences à la base de données Silvaet on assigne une taxonomie à nos données de la Rade de Brest pour pouvoir les étudier. Cette taxonomie va jusqu'à l'espèce. 
```{r}
taxa <- addSpecies(taxa, "~/EcoG2-CC2/silva_species_assignment_v138.fa.gz")
```
```{r}
taxa.print <- taxa # Removing sequence rownames for display only
rownames(taxa.print) <- NULL
head(taxa.print)
```
Après cette assignation taxonomique, nous retrouvons que des bactéries, l'assignation va en grande majorité jusqu'au genre et quelque fois l'espèces. 

# Conclusion

```{r}
save.image(file="02_Dada2_tutorial_FinalEnv")
```



















